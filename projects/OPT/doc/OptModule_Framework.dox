namespace moris {

/** @defgroup Framework Optimization Framework in MORIS

@section OptManager OPT Overview

Optimization in MORIS is handled through the OPT module. This is split up into three major components: The optimization
problem, algorithms, and criteria interfaces. These are set up and controlled by a fourth component, the OPT Manager.
The OPT Manager itself doesn't add any functionality, but it is what takes in all of the parameter list inputs for OPT
and orchestrates the whole optimization process.

As a basic MORIS user, you may never actually work with the Manager. OPT Parameter lists are set up just like the other
modules, where you need a MORIS cell of MORIS cells of parameter lists. This parameter list structure should
automatically be passed to the manager through the MORIS main, and it knows what to do with them. However, the important
thing to remember is that ordering of the parameter lists matter.

The outer cell of parameter lists should always be of size 3, corresponding to 3 sets of parameter lists which then
build the aforementioned 3 major components of OPT. As a summary:

-# The first cell of parameter lists (index 0) defines the optimization problem you're trying to solve. There should
only be 1 parameter list in this cell, which is the OPT problem parameter list.
-# The second cell of parameter lists (index 1) defines what other modules or functions will be providing design criteria
to OPT, known as a Criteria Interface.
-# The third cell of parameter lists (index 2) defines the optimization algorithms to be used to solve the problem.

Each of the major components and their inputs are explained in greater detail in the following sections.

@section OptProblem OPT Problem
As mentioned in the background/theory section, the objectives and constraints of an optimization problem can depend on
both the design variables \f$ \mathbf s \f$ directly as well as the design criteria \f$ \mathbf q \f$. These are the two
types of values that OPT knows about. While it is true that perhaps \f$ \mathbf q \f$ could depend on some field
variables \f$ \mathbf u \f$ which depend on \f$ \mathbf s \f$ through some sort of system solve such as a finite element
analysis, this is not a requirement of a generic optimization problem. Thus, the dependencies of the criteria on the
design variables and other factors is handled by the specific use of the OPT module.

Inside of MORIS, the design variables \f$ \mathbf s \f$ which OPT operates on are referred to as ADVs, or Abstract
Design Variables. This is to prevent confusion with PDVs, which other modules may refer to. ADVs are considered abstract
because at the point that OPT is operating on these design variables, they have no true physical meaning to the
algorithm. They are simply variables which define a design, and what they actually mean is not important to OPT. The
design that a set of ADVs produces is handled by an interface to OPT (see next section).

When dealing with constraints, be aware that the OPT problem stores all of the constraints and the respective gradients
together. This means that equality and inequality constraint values are all given as a vector, and their gradients
are single matrices. OPT distinguishes between equality and inequality and equality constraints through
\ref moris::opt::Problem::get_constraint_types() which returns a vector of identifying integers, 0 for equality and 1
for inequality.

The default parameters in the OPT problem parameter list are created with
\ref moris::prm::create_opt_problem_parameter_list().

\param is_optimization_problem [false]: Whether or not to construct OPT and run an optimization problem. This acts as
    a flag for convenience so that OPT parameter lists do not have to be deleted in order to just run a forward analysis.
\param problem ["user_defined"]: The type of problem. Right now only user-defined problems are supported, but in the
    future if certain optimization problem types become very common, they may be built in as options into MORIS.
\param finite_difference_type ["none"]: Type of finite differencing for gradients. Possible options:
    - "central"
    - "forward"
    - "backward"
    - "none"
\param finite_difference_epsilons ["1E-8"]: Epsilon(s) to use per ADV for finite differencing. This is a string which
    gets converted into a vector of real values. An epsilon can be provided for each ADV in the problem, or a single
    value can be provided, in which case that will be applied to all ADVs.
\param library [""]: Path to a shared object file from which the user-defined problem functions are pulled from. Because
    only user-defined problems are supported right now, this default <b> must be overridden</b>.

@subsection OptProblemUserDefined User-defined OPT Problem
Right now, a \ref moris::opt::Problem_User_Defined "user-defined problem" is the only supported optimization problem
type. In a user-defined OPT problem, all of the pure virtual functions needed to inherit from the base OPT Problem are
supplied through a linked shared object (.so) file. The path to this file is given through the "library" parameter in
the parameter list.

Since each optimization problem is defined with a single method for computing objectives and constraints, the
user-defined functions in the shared object file must have specific names. This also maintains simplicity over having
to give function names as well. These are as follows:
    - get_constraint_types (\ref moris::MORIS_CONSTRAINT_TYPES_FUNCTION "type"):
        Returns a vector of constraint types in the same order that the constraints themselves are provided. 0 Indicates
        an equality constraint, while 1 indicates an inequality constraint. Note that for compatibility reasons with our
        algorithms, right now all equality constraints must be indexed before the inequality constraints.
    - compute_objectives (\ref moris::MORIS_OBJECTIVE_CONSTRAINT_FUNCTION "type"):
        Evaluates the objective. Note that MORIS does not right now support multi-objective optimization, but a single
        objective is still returned in matrix format to make it consistent for HDF5 output as well as to reduce
        additional function types.
    - compute_constraints (\ref moris::MORIS_OBJECTIVE_CONSTRAINT_FUNCTION "type"):
        Evaluates all of the constraints in a vector.
    - compute_dobjective_dadv (\ref moris::MORIS_OBJECTIVE_CONSTRAINT_FUNCTION "type"):
        Evaluates \f$ \frac {\partial f}{\partial \mathbf s} \f$
    - compute_dobjective_dcriteria (\ref moris::MORIS_OBJECTIVE_CONSTRAINT_FUNCTION "type")
        Evaluates \f$ \frac {\partial f}{\partial \mathbf q} \f$
    - compute_dconstraint_dadv (\ref moris::MORIS_OBJECTIVE_CONSTRAINT_FUNCTION "type")
        Evaluates \f$ \frac {\partial \mathbf g }{\partial \mathbf s} \f$ and
        \f$ \frac {\partial \mathbf h }{\partial \mathbf s} \f$
    - compute_dconstraint_dcriteria (\ref moris::MORIS_OBJECTIVE_CONSTRAINT_FUNCTION "type")
        Evaluates \f$ \frac {\partial \mathbf g }{\partial \mathbf q} \f$ and
        \f$ \frac {\partial \mathbf h }{\partial \mathbf q} \f$

@subsection OptProblemNew Adding a New OPT Problem
Some users may want to add problem definitions which are built into MORIS and can be selected using the input parameter
list. To do this, create a new class which inherits from the \ref moris::opt::Problem "base problem class". Define the
pure virtual functions from the base class, which are done similarly to the user-defined case. However, the ADVs and
criteria are protected members, and thus are not passed in as input arguments and instead can be accessed directly in
these functions. Additional functionality can be added here as needed.

In order to have this new problem type be an option that can be selected through the parameter list, add it to the
selection logic in \ref moris::opt::create_problem().

@note Any version of the OPT problem requires that all gradients provided are in standard matrix format. For example,
element (i, j) of \f$ \frac {\partial \mathbf y}{\partial \mathbf x} \f$ corresponds to
\f$ \frac {\partial y_i}{\partial x_j} \f$. This also applies to vectors; a row vector is <b> not the same</b> as a
column vector for gradients in OPT, because OPT cannot determine what you intended.

@section OptAlgorithm OPT Criteria Interfaces
Right now you might be asking, so where do these ADVs and criteria evaluations come from? This is the job of the
OPT Criteria Interface(s) (or just "interface"). OPT is set up to take in interface classes which are able to answer
certain questions for providing criteria evaluations and their gradients with respect to design variables. This is done
so that OPT can be used by any module, for example you could run a sub-optimization problem within a forward analysis.

@section OptCriteria OPT Algorithms



The general nonlinear optimization problem can be solved by diverse iterative methods,
like nonlinear programming or genetic and evolutionary algorithms. For some problems it may
be efficient to apply subsequently different methods. For example, a robust evolutionary
strategy determines roughly the position of the optimum. The final approach is done by a
mathematical program method with a high convergence rate near the optimum.

*/
}