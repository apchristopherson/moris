//------------------------------------------------------------------------------
#include <memory>
#include <string>

// moris core includes
#include "cl_Communication_Manager.hpp"
#include "cl_Communication_Tools.hpp"
#include "typedefs.hpp"

//------------------------------------------------------------------------------
// from LINALG
#include "cl_Matrix.hpp"
#include "fn_norm.hpp"
#include "fn_load_matrix_from_binary_file.hpp"
#include "fn_save_matrix_to_binary_file.hpp"
#include "fn_r2.hpp"
#include "fn_norm.hpp"
#include "HDF5_Tools.hpp"
#include "op_equal_equal.hpp"
#include "fn_all_true.hpp"


//------------------------------------------------------------------------------
// from MTK
#include "cl_Mesh_Enums.hpp"
#include "cl_MTK_Mesh.hpp"
#include "cl_MTK_Mapper.hpp"
#include "cl_Mesh_Factory.hpp"

//------------------------------------------------------------------------------

// geometry engine
#include <GEN/src/cl_GEN_Geometry_Engine.hpp>


//------------------------------------------------------------------------------
// HMR

#include "cl_HMR_Parameters.hpp"
#include "cl_HMR.hpp"
#include "cl_HMR_Database.hpp"
#include "cl_HMR_Mesh.hpp"


#include "cl_HMR_Database.hpp"
#include "cl_HMR_Field.hpp"


//------------------------------------------------------------------------------


// select namespaces
using namespace moris;
using namespace hmr;

real
CircleFunction( const Matrix< DDRMat > & aPoint )
{
    return norm( aPoint ) - 1.2;
}

real
SimionescuFunction( const Matrix< DDRMat > & aPoint )
{
    return 0.1 * aPoint( 0 ) * aPoint ( 1 );
}

//------------------------------------------------------------------------------
// create communicator
moris::Comm_Manager gMorisComm;
//------------------------------------------------------------------------------

/*!
 * \section Facets Tutorial
 * This example creates a simple 2x2 mesh and tests MTK functionality.
 * This example was written for Keenan and will be turned into a test soon.
 */
int
main(
        int    argc,
        char * argv[] )
{
    // initialize MORIS global communication manager
    gMorisComm = moris::Comm_Manager( &argc, &argv );

//------------------------------------------------------------------------------


    // determine path for object file
    std::string tHdf5FilePath = "AbsDesVariables0100.hdf5" ;
    std::string tDatabasePath = "hmr_data.hdf5";
    std::string tMeshPath     = "mbeam.e-s.0100";

//------------------------------------------------------------------------------

      HMR tHMR( tDatabasePath );

//------------------------------------------------------------------------------
//    load density field from mesh
//------------------------------------------------------------------------------

      /**
       * NOTE: This is weired, because the field sits on another block.
       *       MTK does not support this out of the box.
       *       Need to discuss with keenan
       */
      mtk::Mesh * tMesh = mtk::create_mesh( MeshType::STK, tMeshPath, nullptr);

      uint tNumberOfElements
          =  tHMR.get_database()->get_background_mesh()->get_number_of_active_elements_on_proc();


      Matrix< IndexMat > tElements( 1, tNumberOfElements );
      for( uint k=0; k<tNumberOfElements; ++k )
      {
          tElements( k ) = tNumberOfElements+k;
      }

      Matrix< DDRMat > tDensity = tMesh->get_entity_field_value_real_scalar(
              tElements,
              "MatPropStrucDensity",
              EntityRank::ELEMENT );

//------------------------------------------------------------------------------

      /**
       * Flag elements
       */
      // fixme: do not forget maximum refinement
      real tTheshold = 0.25;
      for( uint k=0; k<tNumberOfElements; ++k )
      {
          if( tDensity( k ) > tTheshold )
          {
              tHMR.flag_element( k );
          }
      }

      delete tMesh;
//------------------------------------------------------------------------------

      tHMR.perform_refinement();
      tHMR.finalize();

//------------------------------------------------------------------------------
// Mapping routine
//------------------------------------------------------------------------------
      std::string tLabel = "AbsDesVariables";
      uint tLagrangeOrder = 1;


      // create input mesh
      std::shared_ptr< Mesh > tInputMesh = tHMR.create_mesh( tLagrangeOrder, tHMR.get_parameters()->get_input_pattern() );

      // - - - - - - - - - - - - - - - - - - - -
      // step 1: load coefficients from file
      // - - - - - - - - - - - - - - - - - - - -

      std::shared_ptr< Field > tField = std::make_shared< Field >( tLabel, tInputMesh, tHdf5FilePath );

      // allocate memory for nodes
      tField->get_node_values().set_size( tInputMesh->get_num_nodes(), 1 );

      // - - - - - - - - - - - - - - - - - - - -
      // step 1: calculate node values from coefficients
      // - - - - - - - - - - - - - - - - - - - -

      // create mapper for input
      mapper::Mapper tInputMapper( tInputMesh.get() );

      tInputMapper.perform_mapping(
              tLabel,
              EntityRank::BSPLINE_1,
              tLabel,
              EntityRank::NODE );

      // - - - - - - - - - - - - - - - - - - - -
      // step 2: map coefficients on union mesh
      // - - - - - - - - - - - - - - - - - - - -

      // create union
      auto tUnionMesh = tHMR.create_mesh( tLagrangeOrder, tHMR.get_parameters()->get_union_pattern() );


      auto tUnionField = tUnionMesh->create_field( tLabel, tField->get_bspline_order() );

      // interpolate input field to union
      tHMR.get_database()->interpolate_field(
              tHMR.get_parameters()->get_input_pattern(),
              tField,
              tHMR.get_parameters()->get_union_pattern(),
              tUnionField );

      // - - - - - - - - - - - - - - - - - - - -
      // step 3: Create B-Spline coefficients on union mesh
      // - - - - - - - - - - - - - - - - - - - -

      // create mapper for untion
      mapper::Mapper tUnionMapper( tUnionMesh.get() );

      tUnionMapper.perform_mapping(
              tLabel,
              EntityRank::NODE,
              tLabel,
              EntityRank::BSPLINE_1 );

      // - - - - - - - - - - - - - - - - - - - -
      // step 4: Node values on output mesh
      // - - - - - - - - - - - - - - - - - - - -


      auto tOutputMesh = tHMR.create_mesh( tLagrangeOrder, tHMR.get_parameters()->get_output_pattern() );

      // create mapper for output
      mapper::Mapper tOutputMapper( tOutputMesh.get() );

      std::shared_ptr< Field > tOutputField = tOutputMesh->create_field( tLabel, tField->get_bspline_order() );
      tOutputField->get_node_values().set_size( tOutputMesh->get_num_nodes(), 1 );
      tOutputField->get_coefficients() = tUnionField->get_coefficients();

      tOutputMapper.perform_mapping(
                   tLabel,
                   EntityRank::BSPLINE_1,
                   tLabel,
                   EntityRank::NODE );

      // save exo file
      tHMR.save_to_exodus( 0, "LastStep.exo");
      tHMR.save_to_exodus( "Mesh.exo");

      
//------------------------------------------------------------------------------

    // finalize MORIS global communication manager
    gMorisComm.finalize();

    return 0;

}
