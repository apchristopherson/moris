#
# Copyright (c) 2022 University of Colorado
# Licensed under the MIT license. See LICENSE.txt file in the MORIS root for details.
#
#------------------------------------------------------------------------------------
#

namespace moris {

/** @page MakefileWrapper The Makefile Wrapper

@section MWIntro Introduction

In @p Make, the target @p clean, i.e. <tt>make clean</tt>, deletes 
all the files that the Makefile generated, such as binaries, libraries, 
executables, etc. In @p CMake, there is no such alternative to remove the 
files and directories @p CMake generated, such as @p CMakeCache.txt 
or @p CMakeFiles. Invoking <tt>cmake clean</tt> does nothing, and 
<tt>make clean</tt> performs the same as a Makefile generated without 
@p CMake.

To have better control over the files generated by @p CMake, 
out-of-source 
builds are recommended. In an out-of-source build, @p CMake is invoked 
from a directory different than the one used for the source code. This process 
makes it easier to remove the files and directories generated by 
@p CMake; 
however, the solution is still not ideal as it involves removing the data 
manually by typing <tt>rm -rf build</tt> in the command line.

The goal of this document is to introduce a @p Makefile wrapper for 
@p CMake. The objectives are to hide the process of performing an 
out-of-source build from the user, and to provide an elegant way to clean the 
files and directories generated by @p CMake.

@section OutOfSourceBuild Out-of-source build

When your build generates files, they have to go somewhere. An in-source build 
puts them in your source tree. An out-of-source build puts them in a completely 
separate directory, so that your source tree is unchanged.

In the following example, an in-source build is performed, i.e., the binaries 
are placed in the same directory as the source code.

@verbatim
 cd MORIS
 cmake .
 make
@endverbatim

In the next example, an out-of-source build is performed, i.e., the source 
code, libraries, and executables are produced in a directory separate from the 
source code directory(ies).

@verbatim
 cd MORIS
 mkdir build
 cd build
 cmake ..
 make
@endverbatim

Out-of-source builds are recommended:

-# The separation of the source code and the binaries makes a full clean easier (you just delete the build directory); and 
-# You can build multiple variants in separate directories, e.g., <tt> mkdir build-debug</tt>, @p build-release.

Note: Before performing an out-of-source build, ensure that all @p CMake 
generated in-source build information is removed from the source directory, e.g., 
@p CMakeFiles directory, @p CMakeCache.txt. 

The reader is referred to the following article for more details on 
out-of-source 
builds: 
<a href = "http://www.cmake.org/Wiki/CMake_FAQ#What_is_an_.22out-of-source.22_build.3F"> www.cmake.org </a>.

@section MakefileWrapperCMake Makefile wrapper for CMake

A Makefile wrapper around CMake can be used to ensure the use of out-of-source 
builds, and to provide an easy way to delete all files and directories 
generated 
by CMake. The process to generated this Makefile wrapper is as follows:

In my top-level CMakeLists.txt file, I include the following to prevent 
in-source builds:

@verbatim
if ( ${CMAKE_SOURCE_DIR} STREQUAL ${CMAKE_BINARY_DIR} )
    message( FATAL_ERROR "In-source builds not allowed. Please make a new   \
             directory (called a build directory) and run CMake from there. \
             You may need to remove CMakeCache.txt." )
endif()
@endverbatim

Then, I create a top-level Makefile, and include the following:

@verbatim
# -----------------------------------------------------------------------------
# CMake project wrapper Makefile ----------------------------------------------
# -----------------------------------------------------------------------------

SHELL := /bin/bash
RM    := rm -rf
MKDIR := mkdir -p

all: ./build/Makefile
    @ $(MAKE) -C build

./build/Makefile:
    @  ($(MKDIR) build > /dev/null)
    @  (cd build > /dev/null 2>&1 && cmake ..)

distclean:
    @  ($(MKDIR) build > /dev/null)
    @  (cd build > /dev/null 2>&1 && cmake .. > /dev/null 2>&1)
    @- $(MAKE) --silent -C build clean || true
    @- $(RM) ./build/Makefile
    @- $(RM) ./build/src
    @- $(RM) ./build/test
    @- $(RM) ./build/CMake*
    @- $(RM) ./build/cmake.*
    @- $(RM) ./build/*.cmake
    @- $(RM) ./build/*.txt

ifeq ($(findstring distclean,$(MAKECMDGOALS)),)
    $(MAKECMDGOALS): ./build/Makefile
    @ $(MAKE) -C build $(MAKECMDGOALS)
endif
@endverbatim

The default target @p all is called by typing @p make, and invokes 
the target @p ./build/Makefile.

The first thing the target @p ./build/Makefile does is to create the 
@p build directory using @p \$(MKDIR)}, which is a variable for 
<tt>mkdir -p</tt>. The directory @p build is where we will perform our 
out-of-source build. We provide the argument @p -p to ensure that 
@p mkdir does not scream at us for trying to create a directory that may 
already exist.

The second thing the target @p ./build/Makefile does is to change 
directories to the build directory and invoke @p cmake.

Back to the @p all target, we invoke <tt> $(MAKE) -C build</tt>, where 
<tt>$(MAKE)</tt> is a Makefile variable automatically generated for 
@p make. <tt>make -C</tt> changes the directory before doing anything. 
Therefore, using <tt> $(MAKE) -C build</tt> is equivalent to doing <tt> cd build; make</tt>.

To summarize, calling this Makefile wrapper with <tt>make all</tt> or 
@p make} is equivalent to doing:
@verbatim
mkdir build
cd build
cmake ..
make 
@endverbatim

The target @p distclean invokes <tt>cmake ..</tt>, then <tt>make -C build clean</tt>,
and finally, removes all contents from the @p build directory.

The last piece of the Makefile evaluates if the user-provided target is or is 
not @p distclean. If not, it will change directories to @p build 
before invoking it. This is very powerful because the user can type, for 
example, @p make clean, and the Makefile will transform that into an 
equivalent of <tt>cd build; make clean</tt>.

In conclusion, this Makefile wrapper, in combination with a mandatory 
out-of-source build CMake configuration, make it so that the user never has to 
interact with the command @p cmake. This solution also provides an 
elegant 
method to remove all CMake output files from the @p build directory.

P.S. In the Makefile, we use the prefix @p @ to suppress the output from 
a 
shell command, and the prefix @p @- to ignore errors from a shell 
command. 
When using @p rm as part of the @p distclean target, the command 
will return an error if the files do not exist (they may have been deleted 
already using the command line with <tt>rm -rf build</tt>,
or they were never generated in the first place). This return error 
will force our Makefile to exit. We use the prefix @p @- to prevent that. 
It is acceptable if a file was removed already; we want our Makefile to keep 
going and remove the rest.

Another thing to note: This Makefile may not work if you use a variable number 
of CMake variables to build your project, for example, <tt>cmake .. 
-DSOMEBUILDSUSETHIS:STRING="foo" -DSOMEOTHERBUILDSUSETHISTOO:STRING="bar"</tt>.
This Makefile assumes you invoke CMake in a consistent way, either by typing 
<tt>cmake ..</tt> or by providing @p cmake a consistent number of 
arguments (that you can include in your Makefile).

Finally, credit where credit is due. This Makefile wrapper was adapted from the 
Makefile provided by the 
<a href = "http://code.google.com/p/cpp-project-template/" > C++ Application Project Template </a>.

*/

}
